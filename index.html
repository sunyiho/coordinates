<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>坐标寻宝特工 Coordinate Treasure Agent</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #f4f4ff;
        color: #333;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        padding: 20px;
      }

      .game-wrapper {
        background: #ffffff;
        border-radius: 16px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        padding: 20px 24px 24px;
        max-width: 1000px;
        width: 100%;
        display: grid;
        grid-template-columns: minmax(260px, 1.1fr) minmax(0, 1fr);
        gap: 20px;
      }

      h1 {
        grid-column: 1 / -1;
        text-align: center;
        margin-bottom: 20px;
        font-size: 1.8rem;
        color: #6a00b9;
      }

      .canvas-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      canvas {
        border-radius: 12px;
        background: #fafaff;
        box-shadow: inset 0 0 0 1px rgba(120, 81, 169, 0.3);
        cursor: crosshair;
        width: 100%;
        height: auto;
        max-width: 480px;
        display: block;
      }

      .hint-text {
        font-size: 0.9rem;
        color: #555;
        text-align: center;
      }

      .side-panel {
        display: flex;
        flex-direction: column;
        gap: 14px;
        font-size: 0.95rem;
      }

      .panel-section {
        border-radius: 12px;
        background: #f9f5ff;
        padding: 10px 12px;
        border: 1px solid rgba(120, 81, 169, 0.2);
      }

      .panel-section h2 {
        font-size: 1rem;
        margin-bottom: 6px;
        color: #6a00b9;
      }

      .stats-row {
        display: flex;
        gap: 10px;
        margin-top: 6px;
        flex-wrap: wrap;
      }

      .badge {
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.85rem;
        background: #ede7ff;
        color: #4b0082;
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }

      .badge strong {
        font-weight: 600;
      }

      .big-target {
        font-size: 1.4rem;
        font-weight: bold;
        color: #e65100;
      }

      .feedback {
        margin-top: 4px;
        min-height: 1.2em;
        font-weight: 500;
      }

      .feedback.good {
        color: #2e7d32;
      }

      .feedback.bad {
        color: #c62828;
      }

      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 6px;
      }

      button {
        border-radius: 999px;
        border: none;
        padding: 8px 14px;
        font-size: 0.9rem;
        cursor: pointer;
        background: #7c4dff;
        color: #fff;
        font-weight: 600;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
        transition: transform 0.05s ease, box-shadow 0.05s ease,
          background 0.2s ease;
        white-space: nowrap;
      }

      button:hover {
        background: #673ab7;
        transform: translateY(-1px);
        box-shadow: 0 5px 12px rgba(0, 0, 0, 0.18);
      }

      button:active {
        transform: translateY(0);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      }

      button.secondary {
        background: #ece6ff;
        color: #4b0082;
        box-shadow: none;
      }

      @media (max-width: 900px) {
        .game-wrapper {
          grid-template-columns: 1fr;
        }
        .canvas-container {
          order: 1;
        }
        .side-panel {
          order: 2;
        }
      }

      @media (max-width: 600px) {
        h1 {
          font-size: 1.4rem;
        }
        .controls {
          flex-direction: column;
        }
        .controls button {
          width: 100%;
        }
      }
    </style>
  </head>

  <body>
    <div class="game-wrapper">
      <h1>坐标寻宝特工</h1>

      <div class="canvas-container">
        <canvas id="gridCanvas" width="480" height="480"></canvas>
        <div class="hint-text">提示：点击网格上的整点（交叉点）。</div>
      </div>

      <div class="side-panel">
        <div class="panel-section">
          <h2>当前任务</h2>
          <div>请找到宝藏坐标：</div>
          <div id="targetDisplay" class="big-target">
            点击“开始游戏”生成任务
          </div>
          <div id="feedback" class="feedback"></div>
        </div>

        <div class="panel-section">
          <h2>分数与回合</h2>
          <div class="stats-row">
            <span class="badge">得分：<strong id="scoreDisplay">0</strong></span>
            <span class="badge"
              >回合：<strong id="roundDisplay">0</strong>/<span
                id="maxRoundDisplay"
                >10</span
              ></span
            >
            <span class="badge">正确数：<strong id="correctDisplay">0</strong></span>
          </div>
        </div>

        <div class="panel-section">
          <h2>操作</h2>
          <div class="controls">
            <button id="startBtn">开始游戏</button>
            <button id="restartBtn" class="secondary">重新开始</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gridCanvas");
      const ctx = canvas.getContext("2d");

      let canvasWidth = canvas.width;
      let canvasHeight = canvas.height;

      const marginLeft = 40;
      const marginBottom = 40;
      const marginTop = 30; // 增加顶边距给箭头留空间
      const marginRight = 30; // 增加右边距给箭头留空间
      const maxBase = 10;

      let gridSize;
      let originX;
      let originY;

      function updateGridMetrics() {
        const gridSizeX = (canvasWidth - marginLeft - marginRight) / maxBase;
        const gridSizeY = (canvasHeight - marginTop - marginBottom) / maxBase;
        gridSize = Math.min(gridSizeX, gridSizeY);
        originX = marginLeft;
        originY = canvasHeight - marginBottom;
      }

      function resizeCanvas() {
        const container = canvas.parentElement;
        const containerWidth = container ? container.clientWidth : 480;
        const logicalSize = Math.min(containerWidth, 480);

        canvas.style.width = logicalSize + "px";
        canvas.style.height = logicalSize + "px";
        canvasWidth = canvas.width = logicalSize;
        canvasHeight = canvas.height = logicalSize;

        updateGridMetrics();
        drawGrid();
      }

      let targetX = null;
      let targetY = null;
      let score = 0;
      let round = 0;
      let maxRound = 10;
      let correctCount = 0;
      let isRunning = false;

      const targetDisplay = document.getElementById("targetDisplay");
      const feedback = document.getElementById("feedback");
      const scoreDisplay = document.getElementById("scoreDisplay");
      const roundDisplay = document.getElementById("roundDisplay");
      const maxRoundDisplay = document.getElementById("maxRoundDisplay");
      const correctDisplay = document.getElementById("correctDisplay");
      const startBtn = document.getElementById("startBtn");
      const restartBtn = document.getElementById("restartBtn");

      // 绘制箭头的辅助函数
      function drawArrow(fromX, fromY, toX, toY) {
        const headlen = 10; // 箭头长度
        const angle = Math.atan2(toY - fromY, toX - fromX);
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
      }

      function drawGrid() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = "#fafaff";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // 绘制背景网格
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#e0ddff";
        ctx.beginPath();
        for (let i = 0; i <= maxBase; i++) {
          const x = originX + i * gridSize;
          ctx.moveTo(x, originY);
          ctx.lineTo(x, originY - maxBase * gridSize);

          const y = originY - i * gridSize;
          ctx.moveTo(originX, y);
          ctx.lineTo(originX + maxBase * gridSize, y);
        }
        ctx.stroke();

        // 绘制轴线（带箭头）
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#9c27b0";
        ctx.fillStyle = "#9c27b0";
        
        // X轴箭头
        drawArrow(originX, originY, originX + maxBase * gridSize + 20, originY);
        // Y轴箭头
        drawArrow(originX, originY, originX, originY - maxBase * gridSize - 20);

        // 绘制刻度标签
        ctx.font = "bold 14px system-ui";
        ctx.textAlign = "center";
        for (let i = 0; i <= maxBase; i++) {
          ctx.fillText(i.toString(), originX + i * gridSize, originY + 22);
        }
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        for (let i = 1; i <= maxBase; i++) {
          ctx.fillText(i.toString(), originX - 10, originY - i * gridSize);
        }

        // 绘制轴标签
        ctx.font = "italic bold 16px serif";
        ctx.fillText("x", originX + maxBase * gridSize + 25, originY + 15);
        ctx.fillText("y", originX - 15, originY - maxBase * gridSize - 20);
      }

      function drawClickPoint(x, y, color) {
        const px = originX + x * gridSize;
        const py = originY - y * gridSize;
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      }

      function drawTreasure(x, y) {
        const px = originX + x * gridSize;
        const py = originY - y * gridSize;
        const rOuter = 12, rInner = 6, spikes = 5;
        let rot = (Math.PI / 2) * 3, step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(px, py - rOuter);
        for (let i = 0; i < spikes; i++) {
          ctx.lineTo(px + Math.cos(rot) * rOuter, py + Math.sin(rot) * rOuter);
          rot += step;
          ctx.lineTo(px + Math.cos(rot) * rInner, py + Math.sin(rot) * rInner);
          rot += step;
        }
        ctx.closePath();
        ctx.fillStyle = "#ffb300";
        ctx.fill();
        ctx.strokeStyle = "#f57c00";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function startGame() {
        isRunning = true;
        score = 0;
        round = 1;
        correctCount = 0;
        scoreDisplay.textContent = "0";
        roundDisplay.textContent = "1";
        correctDisplay.textContent = "0";
        feedback.textContent = "";
        resizeCanvas();
        generateTarget();
      }

      function generateTarget() {
        targetX = Math.floor(Math.random() * 10) + 1;
        targetY = Math.floor(Math.random() * 10) + 1;
        targetDisplay.textContent = `(${targetX}, ${targetY})`;
      }

      function handleClick(event) {
        if (!isRunning) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        const gridX = Math.round((mouseX - originX) / gridSize);
        const gridY = Math.round((originY - mouseY) / gridSize);

        if (gridX < 0 || gridX > maxBase || gridY < 0 || gridY > maxBase) return;

        drawGrid();
        drawClickPoint(gridX, gridY, "#03a9f4");

        if (gridX === targetX && gridY === targetY) {
          score += 10;
          correctCount++;
          scoreDisplay.textContent = score;
          correctDisplay.textContent = correctCount;
          feedback.textContent = ""; 
          drawTreasure(targetX, targetY);

          setTimeout(() => {
            round++;
            if (round > maxRound) {
              isRunning = false;
              targetDisplay.textContent = "游戏结束";
              feedback.textContent = `挑战完成！最终得分：${score}`;
              feedback.className = "feedback good";
            } else {
              roundDisplay.textContent = round;
              drawGrid();
              generateTarget();
            }
          }, 600);
        } else {
          score = Math.max(0, score - 2);
          scoreDisplay.textContent = score;
          feedback.textContent = `不对哦，那是 (${gridX}, ${gridY})`;
          feedback.className = "feedback bad";
        }
      }

      canvas.addEventListener("click", handleClick);
      startBtn.addEventListener("click", startGame);
      restartBtn.addEventListener("click", startGame);
      window.addEventListener("resize", resizeCanvas);

      resizeCanvas();
    </script>
  </body>
</html>
